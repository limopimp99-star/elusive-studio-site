<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE PATIENCE OF UZ ‚Ä¢ by MrLive305</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { 
            --gold: #d4af37; 
            --gold-dark: #aa7c11;
            --paper-bg: linear-gradient(145deg, rgba(223,211,182,0.85), rgba(180,140,90,0.85)); 
            --ink: #1a1108; 
            --danger: #8b0000; 
        }
        body,html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; font-family:'VT323',monospace; touch-action:none; }
        
        #game-layout { display:grid; grid-template-columns: 320px 1fr 300px; height:100vh; width:100vw; pointer-events:none; }
        
        .sidebar { 
            pointer-events:auto; background: var(--paper-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 2px solid var(--gold); border-top: none; border-bottom: none;
            box-shadow: inset 0 0 20px rgba(212,175,55,0.1), 0 0 40px rgba(0,0,0,0.8);
            padding:18px; display:flex; flex-direction:column; color:var(--ink); z-index:100;
            transition: background 1.5s ease; overflow-y:auto;
        }
        
        #view-render { position:relative; background:#0c0a08; overflow:hidden; pointer-events: auto; }
        #danger-ring { position:absolute; inset:0; border:0px solid rgba(139,0,0,0); pointer-events:none; transition:0.3s; z-index:300; }

        #ps1-overlay {
            position: fixed; inset: 0; pointer-events: none; z-index: 500;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(30,15,5,0.5) 100%),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIj48ZmlsdGVyIGlkPSJnoiPjxmZVR1cmJ1bGVuY2UgdHlwZT0iZnJhY3RhbE5vaXNlIiBiYXNlRnJlcXVlbmN5PSIwLjY1IiBudW1PY3RhdmVzPSIzIiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI2cpIiBvcGFjaXR5PSIwLjA1Ii8+PC9zdmc+');
            mix-blend-mode: overlay;
        }

        .meter { height:22px; background:#1a1108; border:1px solid var(--gold-dark); margin:2px 0; border-radius:3px; overflow:hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.8); position: relative; }
        .fill { height:100%; transition:width 0.4s cubic-bezier(0.4, 0, 0.2, 1); width:100%; position: relative; overflow: hidden; }
        .fill::after {
            content: ''; position: absolute; top:0; left:-100%; width:50%; height:100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent); animation: shine 2.5s infinite linear;
        }
        @keyframes shine { 100% { left: 200%; } }
        
        .overlay { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(15,10,5,0.95); backdrop-filter: blur(10px); border:2px solid var(--gold); padding:30px; display:none; text-align:center; min-width:400px; z-index:5000; color:white; box-shadow:0 15px 50px #000; cursor:pointer;}
        
        .choice-btn { 
            background: linear-gradient(180deg, #4a3728 0%, #2a1f15 100%); color:white; border: 1px solid var(--gold); border-bottom: 3px solid var(--gold-dark);
            box-shadow: 0 4px 6px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1); text-shadow: 1px 1px 2px #000;
            width:100%; padding:15px; margin:6px 0; cursor:pointer; font-family:'Cinzel'; text-align:left; font-size: 1.05rem; transition:all 0.2s; border-radius: 4px;
        }
        .choice-btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.01); box-shadow: 0 6px 15px rgba(212,175,55,0.3), inset 0 1px 1px rgba(255,255,255,0.3); border-color: #ffe55c; color: #ffe55c; }
        .choice-btn:active:not(:disabled) { transform: translateY(1px); border-bottom-width: 1px; box-shadow: none; }
        
        .world-label { position:absolute; background:rgba(0,0,0,0.7); backdrop-filter: blur(4px); color:var(--gold); border:1px solid var(--gold-dark); padding:4px 10px; white-space:nowrap; pointer-events:none; z-index:1000; font-family:'VT323'; border-radius:6px; transform-origin: center bottom; transition: opacity 0.2s, transform 0.2s; }
        
        #chronicle { flex-grow:1; font-size:1.45em; border-top: 2px solid var(--gold-dark); margin-top:10px; overflow-y:auto; line-height:1.1; padding-top: 10px; }
        #fader { position:fixed; inset:0; background:black; opacity:1; z-index:20000; pointer-events:none; transition: opacity 1.5s; display:flex; justify-content:center; align-items:center; flex-direction:column; color:var(--gold); font-family:'Cinzel'; text-align:center;}
        canvas { image-rendering: pixelated; outline:none; }

        #mobile-ui { display: none; }
        #tab-btn { display:none; }
        
        @media (max-width: 1024px) { 
            #game-layout { grid-template-columns: 1fr; grid-template-rows: 35vh 1fr; }
            #left-sidebar { border-right: none; border-bottom: 3px solid var(--gold); overflow:hidden; padding-bottom: 5px; }
            #right-sidebar { position:fixed; right:-340px; top:0; width:300px; height:100vh; overflow-y:auto; transition:right 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); z-index:9000; box-shadow:-10px 0 30px rgba(0,0,0,0.8); }
            #right-sidebar.active { right:0; }
            #tab-btn { display:block; position:fixed; right:0; top:40%; background:linear-gradient(90deg, #d4af37, #aa7c11); border:1px solid #4a3728; border-right:none; padding:15px 10px; font-family:'Cinzel'; cursor:pointer; z-index:9001; border-radius:10px 0 0 10px; font-weight:bold; color:black; box-shadow: -2px 0 10px rgba(0,0,0,0.5); }
            #mobile-ui { display: block; position: absolute; inset:0; z-index: 1000; pointer-events: none; }
            #joy-right { position: absolute; top:35vh; right:0; width:60vw; height:65vh; pointer-events:auto; touch-action:none; }
            #joy-left { position: absolute; bottom: 80px; left: 30px; width: 140px; height: 140px; background: rgba(255,255,255,0.05); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; pointer-events:auto; touch-action:none; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
            #joy-left-stick { position:absolute; top:45px; left:45px; width:50px; height:50px; background: radial-gradient(circle, rgba(255,255,255,0.9), rgba(200,200,200,0.5)); border-radius:50%; pointer-events:none; box-shadow: 0 4px 10px rgba(0,0,0,0.5); transition: transform 0.05s; }
            .action-btn { position:absolute; border:2px solid rgba(255,255,255,0.4); border-radius:50%; color:#fff; font-size:28px; pointer-events:auto; touch-action:none; display:flex; justify-content:center; align-items:center; box-shadow: 0 8px 32px rgba(0,0,0,0.4), inset 0 0 10px rgba(255,255,255,0.2); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
            .action-btn:active { transform: scale(0.9); }
            #btn-atk { bottom: 80px; right: 30px; width: 85px; height: 85px; background:rgba(200,50,50,0.4); }
            #btn-int { bottom: 180px; right: 45px; width: 65px; height: 65px; background:rgba(50,100,200,0.4); }
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
            "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.webgpu.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
<div id="fader">
    <h1 style="font-size: 3rem; margin-bottom: 10px;">THE PATIENCE OF UZ</h1>
    <p id="loading-text" style="font-family:'VT323'; font-size: 1.5rem; color:#aaa;">Connecting to APEX Network...</p>
</div>
<div id="ps1-overlay"></div>
<div id="tab-btn" onclick="window.toggleMenu()">‚óÄ MENU</div>

<div id="mobile-ui">
    <div id="joy-right"></div>
    <div id="joy-left"><div id="joy-left-stick"></div></div>
    <div class="action-btn" id="btn-atk" onclick="window.executeStaffStrike()">‚öîÔ∏è</div>
    <div class="action-btn" id="btn-int" onclick="window.npcInteraction()">üó£Ô∏è</div>
</div>

<div id="game-layout">
    <div class="sidebar" id="left-sidebar">
        <h1 style="font-family:'Cinzel'; margin:0; font-size:1.8rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);" id="job-title">DAY <span id="v-day">1</span></h1>
        <small id="story-mode">Era of Abundance</small><br>
        <small id="env-mode">Estate of Uz</small>
        <hr style="border: 1px solid var(--gold-dark); width: 100%;">
        
        <label>AP (MENTAL POWER)</label>
        <div class="meter"><div id="ap-fill" class="fill" style="background: linear-gradient(90deg, #2e5c31, #4caf50);"></div></div>
        
        <label style="margin-top:10px;">RIGHTEOUSNESS</label>
        <div class="meter"><div id="al-fill" class="fill" style="background: linear-gradient(90deg, #2a4c6a, #4a749e); width:65%"></div></div>

        <label style="margin-top:10px;">THREAT</label>
        <div class="meter"><div id="th-fill" class="fill" style="background: linear-gradient(90deg, #5c1414, #8b0000); width:0%"></div></div>

        <label style="margin-top:10px;" for="stam">STAMINA</label>
        <div class="meter"><div id="stam-fill" class="fill" style="background: linear-gradient(90deg, #aa8800, #ffcc00); width:100%;"></div></div>
        
        <button id="end-day-btn" class="choice-btn" style="background:linear-gradient(180deg, #2d4a2d, #1a2a1a); margin: 15px 0 5px 0; font-weight:bold; display:none; text-align: center;" onclick="window.nightTransition()">CONCLUDE DAY</button>

        <div id="chronicle"><b>The Scroll of Uz</b><br><br>Job was the greatest man of the East. Establish your herds.</div>
    </div>

    <div id="view-render">
        <div id="danger-ring"></div>
        <div id="labels-hud" style="position:absolute; inset:0; pointer-events:none; z-index:200;"></div>
        <canvas id="ctx-engine" style="width:100%;height:100%;"></canvas>
        
        <div id="script-overlay" class="overlay" style="bottom: 50px; top:auto; transform:translate(-50%,0); width:85%; max-width:700px; cursor:default; background: var(--paper-bg); color:#1a1108; border-image: linear-gradient(#d4af37, #aa7c11) 1;">
            <h2 id="d-name" style="color:#8b0000; margin:0; text-shadow:none;"></h2>
            <p id="d-text" style="font-size: 1.8rem; min-height: 80px;"></p>
            <div id="d-choices"></div>
        </div>

        <div id="ritual-ui" class="overlay" style="min-width:320px;" onclick="window.attemptRitualStrike()">
            <h2 style="font-family:'Cinzel';">SACRED OFFERING</h2>
            <div style="height:35px; background:#111; margin:20px 0; border:2px solid #555; position:relative; box-shadow: inset 0 2px 10px #000;">
                <div id="sweet-spot" style="position:absolute; width:22%; height:100%; background:linear-gradient(90deg, #aa7c11, #ffe55c, #aa7c11); left:39%; box-shadow: 0 0 15px rgba(212,175,55,0.5);"></div>
                <div id="needle" style="position:absolute; width:6px; height:120%; top:-10%; background:#fff; border-radius:3px; box-shadow: 0 0 10px #fff; transition: box-shadow 0.1s;"></div>
            </div>
            <p id="r-status" style="font-size:1.6em;">STRIKES: 0 / 5 (Tap/Space)</p>
        </div>
    </div>

    <div class="sidebar" id="right-sidebar">
        <h2 style="font-family:'Cinzel'; border-bottom:1.5px solid var(--gold-dark); margin:0;">RESOURCES</h2>
        <div style="font-size:1.6rem; background:rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.2); border-radius:4px; padding:10px; margin: 10px 0; box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);">
            üêë Sheep: <span id="v-s" style="transition: transform 0.2s; display:inline-block;">7000</span><br>
            üê´ Camels: <span id="v-c" style="transition: transform 0.2s; display:inline-block;">3000</span><br>
            üåæ Grain: <span id="v-g" style="transition: transform 0.2s; display:inline-block;">140</span><br>
            ü™µ Wood: <span id="v-w" style="transition: transform 0.2s; display:inline-block;">90</span>
        </div>
        
        <h3 style="margin-bottom:5px;">STEWARDSHIP</h3>
        <button class="choice-btn" onclick="window.act('Harvest', 5)">üåæ HARVEST FIELD (5 AP)</button>
        <button class="choice-btn" onclick="window.act('Wood', 5)">ü™µ FELL CEDARS (5 AP)</button>
        <button class="choice-btn" onclick="window.startOffering()" style="background:linear-gradient(180deg, #8b3a1a, #5c1414)">üî• BURNT OFFERING (10 AP)</button>
        <button class="choice-btn" onclick="window.buildAltar()" style="background:linear-gradient(180deg, #666, #333)">ü™® BUILD ALTAR (20 W, 10 AP)</button>
        <button class="choice-btn" onclick="window.expandFold()" style="background:linear-gradient(180deg, #6b8e23, #4a6318)">üöß EXPAND FOLD (30 W, 10 AP)</button>
        <button class="choice-btn" onclick="window.pray()" style="background:linear-gradient(180deg, #285c70, #143544)">üôè PRAY (5 AP)</button>
        <button class="choice-btn" onclick="window.npcInteraction()" style="background:linear-gradient(180deg, #5d4037, #3a2822);">üó£Ô∏è TALK / COMMAND</button>
        
        <button class="choice-btn" onclick="window.lamentOption()" id="btn-lament" style="display:none; background:linear-gradient(180deg, #8b0000, #4a0000)">üå™Ô∏è LAMENT</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { WebGPURenderer } from 'three/webgpu';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

THREE.Cache.enabled = true;

/** ==========================================
 * GAME GLOBALS & ASSET CACHE
 * ========================================== */
const isMobile = window.innerWidth <= 900;
const RENDER_SHADOWS = isMobile ? 1024 : 2048;
const RENDER_DUST = isMobile ? 800 : 2500;
const RENDER_PROPS = isMobile ? 25 : 45;

let scene, camera, renderer, composer, bloomPass, clock, waterMat;
let isWebGPU = false;
let player, heroGrp, donkeyGrp, donkeyLegs = [];
let sim = { day:1, ap:30, grain:140, wood:90, sheep: 7000, camels: 3000, al:60, threat:0, stam:100, mode:'WEALTH', playerState:'MOUNTED', ritual:false, strikes:0, nPos:0, diag:false, round:0, hasAltar:false };
let tags = [], flock = [], birds = [], trees = [], enemies = [], npcs = [], colliders = [];
let camelHerd = [], harvestNodes = [], gameSun, dustSystem, targetCamPos = new THREE.Vector3();
let keys = {}, camYaw = Math.PI, moveVec = {x:0, z:0}, camLastX = 0, joystickMove = false;
let pVelocity = new THREE.Vector3(), pSpeed = 0, pMaxSpeed = 350, pAccel = 1200, pFriction = 8;
let isDisasterRunning = false, lastStaffStrike = 0;

const sheepPenTarget = new THREE.Vector3(600, 0, -850);
const camelPenTarget = new THREE.Vector3(800, 0, -400);

window.activeFires = [];
window.whirlwindGrp = null;
window.typewriterInt = null;
window.treeShaders = [];

// EXTENDED MODEL CACHE FOR NETLIFY LOCAL ASSETS
const modelCache = { 
    sheep: null, camel: null, job: null, donkey: null, wolf: null, raider: null, house: null, cedar: null, 
    bird: null, eliphaz: null, bildad: null, zophar: null, wife: null, servant: null, oxen: null, acacia: null,
    temple: null, bird2: null, buildings: null, clouds: null, shrubs: null, oasis: null, oasis_desert: null, 
    rainbow: null, sheep_enclosure: null, sun: null
};
const animMixers = [];

// === LOD + INSTANCING SYSTEM ===
let sheepInstances = null;
const INSTANCED_COUNT = 80;
const LOD_DISTANCE = 450;

function vibrate(ms) { if(navigator.vibrate) navigator.vibrate(ms); }

/** ==========================================
 * AUDIO SYSTEM
 * ========================================== */
let audioCtx, reverbNode;
const sfx = {
    play: (freq, type='sine', dur=0.4, vol=0.3, detune=0) => {
        if (!audioCtx || audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime); osc.detune.setValueAtTime(detune, audioCtx.currentTime);
        filter.type = 'lowpass'; filter.frequency.setValueAtTime(1200, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        
        osc.connect(filter).connect(gain).connect(reverbNode || audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + dur);
    },
    ui: () => { sfx.play(880, 'triangle', 0.15, 0.4); vibrate(10); },
    harvest: () => { sfx.play(620, 'sawtooth', 0.3, 0.5); sfx.play(1240, 'sine', 0.4, 0.3, 1200); vibrate(30); },
    wood: () => { sfx.play(180, 'square', 0.25, 0.6); vibrate(40); },
    sheep: () => { sfx.play(420, 'sawtooth', 0.6, 0.15); setTimeout(()=>sfx.play(380, 'sawtooth', 0.7, 0.12), 80); },
    hit: () => { sfx.play(90, 'sawtooth', 0.3, 0.7, -800); vibrate(50); },
    wolf: () => sfx.play(240, 'sine', 0.9, 0.4),
    danger: () => { sfx.play(110, 'square', 0.8, 0.5); vibrate([50, 50, 50]); },
    ritualSuccess: () => { sfx.play(1200, 'triangle', 0.6, 0.6); sfx.play(1600, 'sine', 0.8, 0.4); vibrate(40); },
    ritualMiss: () => { sfx.play(300, 'sawtooth', 0.2, 0.3); vibrate(80); }
};

let bgmInterval, isBGMPlaying = false;
function startBGM() {
    if (isBGMPlaying || !audioCtx) return;
    isBGMPlaying = true; let note = 0;
    const melody = [523, 587, 659, 784, 659, 523, 440, 392, 440, 523]; 
    bgmInterval = setInterval(() => {
        if (!isBGMPlaying) return;
        const vol = sim.mode === 'STRUCK' ? 0.12 : 0.25;
        sfx.play(melody[note % melody.length], 'triangle', 0.45, vol, note % 3 === 0 ? 300 : 0);
        sfx.play(melody[(note+2) % melody.length] * 0.5, 'sine', 0.45, vol * 0.6);
        note++; if (sim.state === 'WHIRLWIND') clearInterval(bgmInterval);
    }, 420);
}

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    reverbNode = audioCtx.createConvolverNode();
    const buffer = audioCtx.createBuffer(2, audioCtx.sampleRate * 3, audioCtx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
    }
    reverbNode.buffer = buffer; reverbNode.connect(audioCtx.destination);
    startBGM();
}

window.addEventListener('click', initAudio, {once: true});
window.addEventListener('touchstart', initAudio, {once: true});

function toggleMenu() {
    const side = document.getElementById('right-sidebar');
    const btn = document.getElementById('tab-btn');
    side.classList.toggle('active');
    btn.innerText = side.classList.contains('active') ? '‚ñ∂ CLOSE' : '‚óÄ MENU';
    sfx.ui();
}

function pbrMat(baseColor, roughness=0.85, metalness=0.1) {
    const c = document.createElement('canvas'); c.width = c.height = 128;
    const x = c.getContext('2d');
    x.fillStyle = baseColor; x.fillRect(0,0,128,128);
    for (let i = 0; i < 1200; i++) {
        x.fillStyle = `rgba(0,0,0,${Math.random()*0.25})`;
        x.fillRect(Math.random()*128, Math.random()*128, 2, 2);
    }
    const t = new THREE.CanvasTexture(c);
    t.magFilter = THREE.NearestFilter; t.colorSpace = THREE.SRGBColorSpace;
    return new THREE.MeshStandardMaterial({ map: t, color: baseColor, roughness: roughness, metalness: metalness, envMapIntensity: 1.2 });
}

function enableShadows(obj) {
    if(obj.isMesh) { obj.castShadow = true; obj.receiveShadow = true; }
    if(obj.children) obj.children.forEach(enableShadows);
}

function lerpAngle(start, end, amt) {
    let diff = end - start;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return start + diff * amt;
}

function removeAndDispose(obj) {
    if (!obj) return; scene.remove(obj);
    obj.traverse((child) => {
        if (child.isMesh) {
            child.geometry.dispose();
            if (Array.isArray(child.material)) child.material.forEach(m => m.dispose()); else child.material.dispose();
        }
    });
}

/** ==========================================
 * ASYNC PRELOADER & ENGINE INITIALIZATION
 * ========================================== */
async function preloadAndInit() {
    const loader = new GLTFLoader();
    const txt = document.getElementById('loading-text');
    let loadedCount = 0;
    
    // ‚úÖ CORRECT LOCAL PATH - uses files from your own Netlify repo
   const baseURL = "https://media.githubusercontent.com/limopimp99-star/elusive-studio-site/main/uz-game/assets/";
    
    const modelsToLoad = [
        { name: 'sheep',           path: baseURL + 'sheep.glb' },
        { name: 'camel',           path: baseURL + 'camel.glb' },
        { name: 'job',             path: baseURL + 'shepherd.glb' },
        { name: 'donkey',          path: baseURL + 'donkey_3d_model_free_download.glb' },
        { name: 'wolf',            path: baseURL + 'wolf_with_rigged_and_animation.glb' },
        { name: 'raider',          path: baseURL + 'raider.glb' },
        { name: 'house',           path: baseURL + '1st_century_israelite_house.glb' },
        { name: 'cedar',           path: baseURL + 'cedar_tree.glb' },
        { name: 'bird',            path: baseURL + 'Bird.glb' },
        { name: 'bird2',           path: baseURL + 'Bird2.glb' },
        { name: 'eliphaz',         path: baseURL + 'friend1.glb' },
        { name: 'bildad',          path: baseURL + 'friend2.glb' },
        { name: 'zophar',          path: baseURL + 'friend3-v1.glb' },
        { name: 'wife',            path: baseURL + 'wife.glb' },
        { name: 'servant',         path: baseURL + '_npc.glb' },
        { name: 'oxen',            path: baseURL + 'oxen.glb' },
        { name: 'acacia',          path: baseURL + 'acacia_trees_free_low_poly.glb' },
        { name: 'temple',          path: baseURL + 'ancient_temple.glb' },
        { name: 'buildings',       path: baseURL + 'buildings.glb' },
        { name: 'clouds',          path: baseURL + 'Clouds.glb' },
        { name: 'shrubs',          path: baseURL + 'desert_shrubs.glb' },
        { name: 'oasis',           path: baseURL + 'oasis.glb' },
        { name: 'oasis_desert',    path: baseURL + 'oasis_-_desert.glb' },
        { name: 'rainbow',         path: baseURL + 'RainbowWithClouds.glb' },
        { name: 'sheep_enclosure', path: baseURL + 'sheep_in_its_enclosure.glb' },
        { name: 'sun',             path: baseURL + 'Sun.glb' }
    ];

    const promises = modelsToLoad.map(m => {
        return loader.loadAsync(m.path)
            .then(gltf => {
                modelCache[m.name] = gltf;
                loadedCount++;
                txt.innerText = `Loading Assets... (${loadedCount}/${modelsToLoad.length})`;
                console.log(`‚úÖ Loaded: ${m.name}`);
            })
            .catch(err => {
                console.error(`‚ùå Failed to load ${m.name} ‚Üí ${m.path}`, err);
                modelCache[m.name] = null;
                loadedCount++;
                txt.innerText = `Loading... (${loadedCount}/${modelsToLoad.length}) - some missing`;
            });
    });

    await Promise.all(promises);
    console.log("‚úÖ All model loading finished");
    await initEngine();
    setTimeout(() => { document.getElementById('fader').style.opacity = 0; }, 600);
}

async function initEngine() {
    const view = document.getElementById('view-render');
    scene = new THREE.Scene(); clock = new THREE.Clock();

    camera = new THREE.PerspectiveCamera(65, view.clientWidth/view.clientHeight, 1, 6000);
    
    // WEBGPU RENDERER UPGRADE
    if (navigator.gpu) {
        try {
            renderer = new WebGPURenderer({
                canvas: document.getElementById('ctx-engine'),
                antialias: true,
                powerPreference: "high-performance"
            });
            await renderer.init();
            isWebGPU = true;
            console.log("üöÄ Running in Next-Gen WebGPU Mode");
        } catch (e) {
            console.warn("WebGPU init failed, falling back to WebGL", e);
            renderer = new THREE.WebGLRenderer({canvas: document.getElementById('ctx-engine'), antialias:false});
        }
    } else {
        renderer = new THREE.WebGLRenderer({canvas: document.getElementById('ctx-engine'), antialias:false});
        console.log("üéÆ Running in WebGL Fallback Mode");
    }

    renderer.setSize(view.clientWidth, view.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    
    // 2026 Polish: Explicit shadow map needsUpdate
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;
    renderer.shadowMap.needsUpdate = true;

    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = isMobile ? THREE.NoToneMapping : THREE.ACESFilmicToneMapping;
    if(!isMobile) renderer.toneMappingExposure = 1.15;

    // COMPOSER SETUP
    if (!isWebGPU) {
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
        composer.addPass(bloomPass);
    }

    new RGBELoader().setPath('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/').load('royal_esplanade_1k.hdr', function(texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping; scene.environment = texture;
    });

    gameSun = new THREE.DirectionalLight(0xfff0dd, 1.5);
    gameSun.position.set(300, 800, -500); gameSun.castShadow = true;
    gameSun.shadow.mapSize.width = RENDER_SHADOWS; gameSun.shadow.mapSize.height = RENDER_SHADOWS;
    const d = 1500; gameSun.shadow.camera.left = -d; gameSun.shadow.camera.right = d; gameSun.shadow.camera.top = d; gameSun.shadow.camera.bottom = -d;
    scene.add(gameSun); scene.add(new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.6));

    const tGeo = new THREE.PlaneGeometry(6000, 6000, 128, 128);
    const pos = tGeo.attributes.position;
    for(let i=0; i < pos.count; i++){
        const x = pos.getX(i); const y = pos.getY(i);
        const z = (Math.sin(x * 0.002) * 40) + (Math.cos(y * 0.003) * 40) + (Math.sin(x*0.01 + y*0.01)*5);
        const dist = Math.sqrt(x*x + y*y); const flatten = Math.max(0, 1 - (dist / 800)); 
        pos.setZ(i, z * (1 - flatten)); 
    }
    tGeo.computeVertexNormals(); window.terrainGeo = tGeo;
    const terrain = new THREE.Mesh(tGeo, pbrMat('#48942b', 0.9, 0.1));
    terrain.rotation.x = -Math.PI / 2; terrain.receiveShadow = true; scene.add(terrain);

    // WATER SHADER
    waterMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `uniform float time; varying vec2 vUv; void main() { vec2 uv = vUv; uv.y += time * 0.1; gl_FragColor = vec4(0.1, 0.4, 0.8, 0.6 + sin(uv.y * 20.0)*0.1); }`,
        transparent: true
    });
    const river = new THREE.Mesh(new THREE.PlaneGeometry(150, 6000), waterMat);
    river.rotation.x = -Math.PI/2; river.position.set(-800, 5, 0); scene.add(river);

    const vShader = `varying vec3 vWorldPos; void main() { vec4 worldPos = modelMatrix * vec4( position, 1.0 ); vWorldPos = worldPos.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fShader = `uniform vec3 topColor; uniform vec3 botColor; uniform float offset; uniform float exp; varying vec3 vWorldPos; void main() { float h = normalize( vWorldPos + offset ).y; gl_FragColor = vec4( mix( botColor, topColor, max( pow( max( h , 0.0), exp ), 0.0 ) ), 1.0 ); }`;
    const sky = new THREE.Mesh( new THREE.SphereGeometry( 4000, 32, 15 ), new THREE.ShaderMaterial({ 
        vertexShader: vShader, fragmentShader: fShader, side: THREE.BackSide,
        uniforms: { topColor: { value: new THREE.Color(0x0077ff) }, botColor: { value: new THREE.Color(0xffffff) }, offset: { value: 33 }, exp: { value: 0.6 } }
    }));
    scene.add( sky ); scene.fog = new THREE.FogExp2( 0xe6e0d4, isMobile ? 0.0004 : 0.0006 );

    const dustGeo = new THREE.BufferGeometry(); const dustPos = new Float32Array(RENDER_DUST * 3);
    for(let i=0; i<RENDER_DUST*3; i++) dustPos[i] = (Math.random() - 0.5) * 1000;
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    dustSystem = new THREE.Points(dustGeo, new THREE.PointsMaterial({color: 0xffaa00, size: 2, transparent: true, opacity: 0.6})); scene.add(dustSystem);

    buildMountSystem(); createMapStuff(); setupMobileControls(); spawnVillageDetail(); spawnVultures(); scene.traverse(enableShadows);
    
    window.onkeydown=e=>{ keys[e.key.toLowerCase()]=true; if(e.code === 'Space') attemptRitualStrike(); if(e.code === 'Space' && !sim.ritual) executeStaffStrike(); };
    window.onkeyup=e=>keys[e.key.toLowerCase()]=false;
    view.onmousemove=e=>{ if(document.pointerLockElement) camYaw -= e.movementX*0.0035; };
    view.onclick=()=> { if(!sim.diag && !sim.ritual) { view.requestPointerLock(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } if(!sim.ritual) executeStaffStrike(); };

    window.onresize = () => {
        camera.aspect = view.clientWidth / view.clientHeight; camera.updateProjectionMatrix();
        renderer.setSize(view.clientWidth, view.clientHeight); 
        if(!isWebGPU) composer.setSize(view.clientWidth, view.clientHeight);
    };
    updateHUD(); startLoop();
}

/** ==========================================
 * GLTF HYBRID SYSTEM (FALLBACK TO PS1 BOXES)
 * ========================================== */
function buildMountSystem() {
    player = new THREE.Group(); donkeyGrp = new THREE.Group(); heroGrp = new THREE.Group();
    
    // DONKEY
    if (modelCache.donkey) {
        const dModel = SkeletonUtils.clone(modelCache.donkey.scene);
        dModel.scale.set(15,15,15); 
        const mixer = new THREE.AnimationMixer(dModel);
        if(modelCache.donkey.animations && modelCache.donkey.animations.length > 0) mixer.clipAction(modelCache.donkey.animations[0]).play();
        animMixers.push({mixer: mixer, obj: dModel, type: 'donkey'});
        donkeyGrp.add(dModel);
        donkeyGrp.userData = { isGLTF: true, model: dModel };
    } else {
        const dMat = pbrMat('#8e8371', 0.8);
        const dBody = new THREE.Mesh(new THREE.BoxGeometry(22, 26, 48), dMat); dBody.position.y=24;
        const dNeck = new THREE.Mesh(new THREE.BoxGeometry(10, 18, 12), dMat); dNeck.position.set(0, 38, 20); dNeck.rotation.x=0.3;
        const dSnout = new THREE.Mesh(new THREE.BoxGeometry(8, 10, 14), pbrMat('#a89f91')); dSnout.position.set(0, 42, 28);
        donkeyGrp.add(dBody, dNeck, dSnout);
        for(let i=0; i<4; i++){
            const j = new THREE.Group(); const leg = new THREE.Mesh(new THREE.CylinderGeometry(3.5,3.5,20), dMat); leg.position.y=-10; 
            j.add(leg); j.position.set(i%2?9:-9, 14, i<2?17:-17); donkeyGrp.add(j); donkeyLegs.push(j);
        }
        donkeyGrp.userData = { isGLTF: false };
    }
    
    // HERO
    heroGrp.position.set(0,55,0);
    if (modelCache.job) {
        const jModel = SkeletonUtils.clone(modelCache.job.scene);
        jModel.scale.set(15,15,15); 
        const mixer = new THREE.AnimationMixer(jModel);
        if(modelCache.job.animations && modelCache.job.animations.length > 0) mixer.clipAction(modelCache.job.animations[0]).play();
        animMixers.push({mixer: mixer, obj: jModel, type: 'job'});
        heroGrp.add(jModel);
    } else {
        const heroBody = new THREE.Mesh(new THREE.BoxGeometry(18,28,18), pbrMat('#c5a059')); 
        const heroHead = new THREE.Mesh(new THREE.BoxGeometry(10,10,10), pbrMat('#d2b48c', 0.9)); heroHead.position.y = 19;
        heroGrp.add(heroBody, heroHead);
    }

    const staff = new THREE.Mesh(new THREE.CylinderGeometry(2,2,90,8), pbrMat('#3d2723')); staff.position.set(16, -10, 10); staff.rotation.x = -0.2; 
    heroGrp.add(staff); window.staffMesh = staff;

    player.add(donkeyGrp); player.add(heroGrp); scene.add(player); player.position.set(500,0,500);
}

function spawnSheep() {
    if (!sheepInstances && modelCache.sheep) {
        let geo, mat;
        modelCache.sheep.scene.traverse(child => {
            if (child.isMesh && !geo) { geo = child.geometry; mat = child.material; }
        });
        if(!geo) geo = new THREE.SphereGeometry(9, 8, 8);
        if(!mat) mat = pbrMat('#f0f0f0');
        
        sheepInstances = new THREE.InstancedMesh(geo, mat, INSTANCED_COUNT);
        sheepInstances.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(sheepInstances);
    }
    const sGroup = new THREE.Group();
    let isGLTF = false;
    
    if (modelCache.sheep) {
        const sModel = SkeletonUtils.clone(modelCache.sheep.scene);
        sModel.scale.set(10, 10, 10);
        const mixer = new THREE.AnimationMixer(sModel);
        if (modelCache.sheep.animations && modelCache.sheep.animations.length) mixer.clipAction(modelCache.sheep.animations[0]).play();
        animMixers.push({mixer, obj: sGroup, type: 'sheep'});
        sGroup.add(sModel);
        isGLTF = true;
    } else {
        const body = new THREE.Mesh(new THREE.SphereGeometry(9, 12, 12), pbrMat('#f0f0f0', 0.95)); body.position.y = 11;
        sGroup.add(body);
        sGroup.userData.body = body; // fallback animation target
    }

    sGroup.position.set((Math.random()-0.5)*2000, 0, (Math.random()-0.5)*2000);
    sGroup.userData = { type: 'sheep', isGLTF: isGLTF, secured:false, state: 'GRAZE', fear: 0, grazeTimer: 0, speed: 0, maxSpeed: 45, velocity: new THREE.Vector3(), targetDir: new THREE.Vector3(0,0,1), targetYaw: 0, baseY: 0, instanceIndex: -1 };
    scene.add(sGroup); flock.push(sGroup);
}

function updateInstancedFlock() {
    if (!sheepInstances) return;
    let idx = 0;
    flock.forEach(s => {
        if (s.userData.isGLTF && camera.position.distanceTo(s.position) > LOD_DISTANCE && idx < INSTANCED_COUNT) {
            const matrix = new THREE.Matrix4();
            matrix.makeRotationY(s.rotation.y);
            matrix.setPosition(s.position);
            matrix.scale(new THREE.Vector3(10,10,10));
            sheepInstances.setMatrixAt(idx, matrix);
            s.visible = false;
            s.userData.instanceIndex = idx;
            idx++;
        } else {
            s.visible = true;
            if (s.userData.instanceIndex >= 0) {
                sheepInstances.setMatrixAt(s.userData.instanceIndex, new THREE.Matrix4().scale(new THREE.Vector3(0,0,0)));
                s.userData.instanceIndex = -1;
            }
        }
    });
    sheepInstances.instanceMatrix.needsUpdate = true;
    sheepInstances.count = Math.max(0, idx); 
}

function spawnCamel() {
    const cGroup = new THREE.Group();
    const cLegs = [];
    let isGLTF = false;

    if (modelCache.camel) {
        const cModel = SkeletonUtils.clone(modelCache.camel.scene);
        cModel.scale.set(18,18,18); 
        const mixer = new THREE.AnimationMixer(cModel);
        if(modelCache.camel.animations && modelCache.camel.animations.length > 0) mixer.clipAction(modelCache.camel.animations[0]).play();
        animMixers.push({mixer: mixer, obj: cGroup, type: 'camel'});
        cGroup.add(cModel);
        isGLTF = true;
    } else {
        const body = new THREE.Mesh(new THREE.BoxGeometry(18,22,35), pbrMat('#c19a6b')); body.position.y = 25;
        const neck = new THREE.Mesh(new THREE.BoxGeometry(8,20,8), pbrMat('#c19a6b')); neck.position.set(0, 40, 15); neck.rotation.x = 0.2;
        const hump1 = new THREE.Mesh(new THREE.SphereGeometry(8, 8, 8), pbrMat('#a67f52')); hump1.position.set(0, 35, -5);
        for(let j=0; j<4; j++) { 
            const legGrp = new THREE.Group();
            const cLeg = new THREE.Mesh(new THREE.CylinderGeometry(2,2,20), pbrMat('#c19a6b')); cLeg.position.y = 10;
            legGrp.add(cLeg); legGrp.position.set(j%2?7:-7, 0, j<2?12:-12); cGroup.add(legGrp); cLegs.push(legGrp); 
        }
        cGroup.add(body, neck, hump1);
        cGroup.userData.body = body;
    }

    cGroup.position.set(400 + Math.random()*400, 0, -600 + Math.random()*400);
    cGroup.userData = { type: 'camel', isGLTF: isGLTF, secured:false, state: 'GRAZE', fear: 0, grazeTimer: 0, speed: 0, maxSpeed: 60, velocity: new THREE.Vector3(), targetDir: new THREE.Vector3(0,0,1), targetYaw: 0, legs: cLegs, baseY: 25 };
    scene.add(cGroup); camelHerd.push(cGroup);
}

function spawnBuild(x,z,txt,col,h,radius, modelName=null) {
    const g = new THREE.Group();
    if(modelName && modelCache[modelName]) {
        const m = SkeletonUtils.clone(modelCache[modelName].scene);
        m.scale.set(10,10,10); 
        g.add(m);
    } else {
        const b = new THREE.Mesh(new THREE.BoxGeometry(200, h, 200), pbrMat('#'+col.toString(16), 0.9));
        b.position.y=h/2; g.add(b);
    }
    g.position.set(x,0,z); g.userData={label:txt}; scene.add(g); tags.push(g); colliders.push({pos: new THREE.Vector3(x,0,z), radius: radius});
}

function createMapStuff() {
    spawnBuild(-450, -600, "Job's Grand Household", 0xe8b050, 190, 120, 'house');
    
    if(modelCache.sheep_enclosure) {
        spawnBuild(600, -850, "Sheep Fold", 0x8b5a2b, 80, 120, 'sheep_enclosure');
    } else {
        const fold = new THREE.Group(); const fenceMat = pbrMat('#5d4037', 0.8);
        for (let i=0; i<8; i++) {
            const post = new THREE.Mesh(new THREE.BoxGeometry(6,35,6), fenceMat); post.position.set(-175 + i*50, 17, -100); fold.add(post);
            const rail = new THREE.Mesh(new THREE.BoxGeometry(50,8,6), fenceMat); rail.position.set(-150 + i*50, 28, -100); fold.add(rail);
        }
        fold.position.set(600, 0, -850); scene.add(fold); tags.push({position: new THREE.Vector3(600, 50, -950), userData: {label: "Sheep Fold"}});
    }

    spawnBuild(800, -400, "Camel Enclosure", 0xa67f52, 60, 150);
    
    const servants = [
        {n:"Steward Eli", m:"servant", x:-200, z:-100}, 
        {n:"Leah", m:"wife", x:100, z:100}
    ];
    servants.forEach(s=>{
        const g = new THREE.Group();
        if(modelCache[s.m]) {
            const m = SkeletonUtils.clone(modelCache[s.m].scene);
            m.scale.set(10,10,10); 
            g.add(m);
        } else {
            const body = new THREE.Mesh(new THREE.BoxGeometry(16,30,16), pbrMat('#285c70')); body.position.y=15;
            g.add(body);
        }
        g.position.set(s.x, 0, s.z); g.userData = { label:s.n, target: new THREE.Vector3(s.x, 0, s.z), task: 'IDLE', prompted: false };
        scene.add(g); tags.push(g); npcs.push(g);
    });

    for(let i=0; i<16; i++) spawnSheep();
    for(let i=0; i<5; i++) spawnCamel();

    for(let i=0; i<15; i++) {
        const grain = new THREE.Mesh(new THREE.BoxGeometry(15, 20, 15), pbrMat('#eadd6e')); grain.position.set((Math.random()-0.5)*1500, 10, (Math.random()-0.5)*1500);
        grain.userData = { type: 'grain', hp: 1, label: "Wheat Field" }; scene.add(grain); harvestNodes.push(grain); tags.push(grain);
    }

    window.treeShaders = [];
    const treeMat = pbrMat('#2d4a2d', 0.8);
    treeMat.onBeforeCompile = shader => {
        shader.uniforms.time = { value: 0 };
        shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `#include <begin_vertex>
            transformed.x += sin(time * 2.0 + position.y * 0.1) * 2.0;`
        );
        window.treeShaders.push(shader);
    };

    for(let i=0; i<30; i++) {
        const tGroup = new THREE.Group();
        const useAcacia = modelCache.acacia && Math.random() > 0.5;
        
        if (useAcacia) {
            const m = SkeletonUtils.clone(modelCache.acacia.scene);
            m.scale.set(20,20,20); 
            tGroup.add(m);
            tGroup.userData = { type: 'wood', hp: 3, label: "Acacia Tree" };
        } else if (modelCache.cedar) {
            const m = SkeletonUtils.clone(modelCache.cedar.scene);
            m.scale.set(20,20,20); 
            tGroup.add(m);
            tGroup.userData = { type: 'wood', hp: 3, label: "Cedar Tree" };
        } else {
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(4,6,40), pbrMat('#3d2723')); trunk.position.y = 20;
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(20, 0), treeMat); leaves.position.y = 45;
            tGroup.add(trunk, leaves);
            tGroup.userData = { type: 'wood', hp: 3, label: "Cedar Tree" };
        }
        tGroup.position.set((Math.random()-0.5)*3000, 0, (Math.random()-0.5)*3000);
        scene.add(tGroup); trees.push(tGroup); harvestNodes.push(tGroup); colliders.push({pos: tGroup.position, radius: 10});
    }
    
    if(modelCache.shrubs) {
        for(let i=0; i<20; i++) {
            const shGrp = new THREE.Group();
            const m = SkeletonUtils.clone(modelCache.shrubs.scene);
            m.scale.set(10,10,10);
            shGrp.add(m);
            shGrp.position.set((Math.random()-0.5)*3000, 0, (Math.random()-0.5)*3000);
            scene.add(shGrp);
        }
    }

    for(let i=0; i<6; i++) {
        const oGroup = new THREE.Group();
        if (modelCache.oxen) {
            const m = SkeletonUtils.clone(modelCache.oxen.scene);
            m.scale.set(12,12,12); 
            const mixer = new THREE.AnimationMixer(m);
            if(modelCache.oxen.animations && modelCache.oxen.animations.length > 0) mixer.clipAction(modelCache.oxen.animations[0]).play();
            animMixers.push({mixer: mixer, obj: oGroup});
            oGroup.add(m);
        } else {
            const oBody = new THREE.Mesh(new THREE.BoxGeometry(20, 15, 30), pbrMat('#553311')); oBody.position.y = 12;
            oGroup.add(oBody);
        }
        oGroup.position.set((Math.random()-0.5)*1500 - 500, 0, (Math.random()-0.5)*1500 - 500);
        oGroup.userData = { type: 'oxen', secured:false, state: 'GRAZE', fear: 0, grazeTimer: 0, speed: 0, maxSpeed: 30, velocity: new THREE.Vector3(), targetDir: new THREE.Vector3(0,0,1), targetYaw: 0, isGLTF: !!modelCache.oxen };
        scene.add(oGroup); camelHerd.push(oGroup); 
    }
}

function spawnVultures() {
    for(let i=0; i<6; i++) {
        const bird = new THREE.Group(); 
        const useBird2 = modelCache.bird2 && Math.random() > 0.5;
        const bModelData = useBird2 ? modelCache.bird2 : modelCache.bird;

        if (bModelData) {
            const m = SkeletonUtils.clone(bModelData.scene);
            m.scale.set(5,5,5); 
            const mixer = new THREE.AnimationMixer(m);
            if(bModelData.animations && bModelData.animations.length > 0) mixer.clipAction(bModelData.animations[0]).play();
            animMixers.push({mixer: mixer, obj: bird});
            bird.add(m);
            bird.userData.isGLTF = true;
        } else {
            const wingMat = new THREE.MeshStandardMaterial({color: 0x111111, emissive: 0x222222, emissiveIntensity: 0.4, side: THREE.DoubleSide});
            const wingL = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), wingMat); wingL.position.set(-15, 2, 0); 
            const wingR = wingL.clone(); wingR.position.x = 15;
            bird.add(wingL, wingR);
            bird.userData.wingL = wingL; bird.userData.wingR = wingR;
            bird.userData.isGLTF = false;
        }
        bird.userData = { ...bird.userData, speed: 0.01 + Math.random() * 0.02, height: 350 + Math.random() * 100, angle: Math.random() * Math.PI * 2 }; 
        scene.add(bird); birds.push(bird);
    }
}

function spawnWolf(x,z){
    const wolf = new THREE.Group(); 
    if(modelCache.wolf) {
        const m = SkeletonUtils.clone(modelCache.wolf.scene);
        m.scale.set(10,10,10); 
        const mixer = new THREE.AnimationMixer(m);
        if(modelCache.wolf.animations && modelCache.wolf.animations.length > 0) mixer.clipAction(modelCache.wolf.animations[0]).play();
        animMixers.push({mixer: mixer, obj: wolf});
        wolf.add(m);
    } else {
        const wBody = new THREE.Mesh(new THREE.BoxGeometry(10,12,25), pbrMat('#555555')); wBody.position.y=10; 
        wolf.add(wBody);
    }
    wolf.position.set(x,0,z); wolf.userData = { type:'wolf', state:'PATROL', hp:60, cooldown: 0 }; scene.add(wolf); enemies.push(wolf);
}

function createRaiderMesh(x, z) {
    const rGroup = new THREE.Group();
    if(modelCache.raider) {
        const m = SkeletonUtils.clone(modelCache.raider.scene);
        m.scale.set(10,10,10); 
        const mixer = new THREE.AnimationMixer(m);
        if(modelCache.raider.animations && modelCache.raider.animations.length > 0) mixer.clipAction(modelCache.raider.animations[0]).play();
        animMixers.push({mixer: mixer, obj: rGroup});
        rGroup.add(m);
    } else {
        const rBody = new THREE.Mesh(new THREE.BoxGeometry(20, 52, 20), pbrMat('#8b0000')); rBody.position.y = 26; 
        rGroup.add(rBody); 
    }
    rGroup.position.set(x, 0, z); rGroup.userData = { type: 'raider', hp: 100, state: 'PATROL', cooldown: 0 }; scene.add(rGroup); enemies.push(rGroup); tags.push(rGroup); rGroup.userData.label = "Sabean Raider";
}

function spawnVillageDetail() {
    const props = [ { name: "Cedar Pile", color: '#5d4037', h: 10, w: 40 }, { name: "Clay Jars", color: '#a0522d', h: 25, w: 15 }, { name: "Market Stand", color: '#8b5a2b', h: 60, w: 60 } ];
    for(let i=0; i<RENDER_PROPS; i++) {
        const type = props[Math.floor(Math.random() * props.length)];
        const x = (Math.random() - 0.5) * 3500; const z = (Math.random() - 0.5) * 3500;
        if(Math.hypot(x, z) < 300 || Math.abs(x) < 100 || Math.abs(z) < 100) continue;
        
        if (modelCache.buildings && Math.random() > 0.5) {
            spawnBuild(x, z, type.name, type.color, type.h, type.w/2, 'buildings');
        } else {
            const group = new THREE.Group(); const mesh = new THREE.Mesh(new THREE.BoxGeometry(type.w, type.h, type.w), pbrMat(type.color));
            mesh.position.y = type.h/2; group.add(mesh); group.position.set(x, 0, z);
            if(Math.random() > 0.8) { group.userData = { label: type.name }; tags.push(group); }
            scene.add(group); colliders.push({pos: new THREE.Vector3(x,0,z), radius: type.w/2});
        }
    }
}

/**
 * ELEMENTAL VFX GENERATORS
 */
function spawnFire(x, z) {
    const fireGrp = new THREE.Group();
    const fMat = new THREE.MeshBasicMaterial({color: 0xff8800, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false});
    const sMat = new THREE.MeshBasicMaterial({color: 0x333333, transparent: true, opacity: 0.6});
    const light = new THREE.PointLight(0xffaa00, 3, 500); light.position.y = 20; fireGrp.add(light);

    for(let i=0; i<40; i++) {
        const isSmoke = i > 20; const p = new THREE.Mesh(new THREE.BoxGeometry(15,15,15), isSmoke ? sMat : fMat);
        p.userData = { yOffset: Math.random() * 40, speed: Math.random() * 0.15 + 0.05, yMax: isSmoke ? 150 + Math.random()*100 : 50 + Math.random()*50, isSmoke: isSmoke };
        p.position.set((Math.random()-0.5)*80, p.userData.yOffset, (Math.random()-0.5)*80); fireGrp.add(p);
    }
    fireGrp.position.set(x, getTerrainHeight(x,z), z); scene.add(fireGrp); window.activeFires.push(fireGrp);
}

function spawnWhirlwind() {
    window.whirlwindGrp = new THREE.Group();
    const wMat = new THREE.MeshStandardMaterial({color: 0x111111, transparent: true, opacity: 0.9, side: THREE.DoubleSide});
    const dMat = new THREE.MeshStandardMaterial({color: 0x555555}); 

    for(let i=0; i<100; i++) { 
        const radius = 10 + (i * 4); const p = new THREE.Mesh(new THREE.BoxGeometry(radius, 25, 12), wMat); p.position.y = i * 20;
        p.userData = { speed: 0.05 + (i * 0.001), angle: Math.random() * Math.PI * 2, radius: radius, isDebris: false }; window.whirlwindGrp.add(p);
        if (i % 3 === 0) {
            const deb = new THREE.Mesh(new THREE.BoxGeometry(10,10,10), dMat); deb.position.y = i * 20 + Math.random()*50;
            deb.userData = { speed: 0.08, angle: Math.random() * Math.PI * 2, radius: radius + 40, isDebris: true }; window.whirlwindGrp.add(deb);
        }
    }
    window.whirlwindGrp.position.copy(player.position); window.whirlwindGrp.position.z -= 600; scene.add(window.whirlwindGrp);
}

function setupMobileControls() {
    const joyL = document.getElementById('joy-left'); const stick = document.getElementById('joy-left-stick'); const joyR = document.getElementById('joy-right');
    if(!joyL) return;

    let jId = null, camId = null; let jStart = {x:0, y:0};
    joyL.addEventListener('touchstart', e => {
        e.preventDefault(); const t = e.changedTouches[0]; jId = t.identifier; jStart = { x: t.clientX, y: t.clientY }; joystickMove = true;
    }, {passive: false});

    joyL.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let touch of e.changedTouches) {
            if(touch.identifier === jId) {
                const dx = touch.clientX - jStart.x; const dy = touch.clientY - jStart.y; const dist = Math.min(45, Math.hypot(dx, dy)); const angle = Math.atan2(dy, dx);
                stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                moveVec = { x: (Math.cos(angle)*dist)/45, z: (Math.sin(angle)*dist)/45 };
            }
        }
    }, {passive: false});

    const stopJoy = () => { joystickMove = false; moveVec = {x:0, z:0}; stick.style.transform = `translate(0px, 0px)`; jId = null; };
    joyL.addEventListener('touchend', stopJoy); joyL.addEventListener('touchcancel', stopJoy);

    joyR.addEventListener('touchstart', e => { e.preventDefault(); const t = e.changedTouches[0]; camId = t.identifier; camLastX = t.clientX; }, {passive: false});
    joyR.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let touch of e.changedTouches) { if(touch.identifier === camId) { const dx = touch.clientX - camLastX; camYaw -= dx * 0.0065; camLastX = touch.clientX; } }
    }, {passive: false});

    const stopCam = () => { camId = null; };
    joyR.addEventListener('touchend', stopCam); joyR.addEventListener('touchcancel', stopCam);
}

function getTerrainHeight(x, z) {
    if(!window.terrainGeo) return 0; if(isNaN(x) || isNaN(z)) return 0;
    const pos = window.terrainGeo.attributes.position; const size = 6000; const half = size / 2; const segments = 128;
    let gridX = Math.floor(((x + half) / size) * segments); let gridZ = Math.floor(((z + half) / size) * segments);
    gridX = Math.max(0, Math.min(segments, gridX)); gridZ = Math.max(0, Math.min(segments, gridZ));
    const index = gridZ * (segments + 1) + gridX; if(index < 0 || index >= pos.count) return 0;
    return pos.getZ(index);
}

function handleCollisions() {
    colliders.forEach(obj => {
        const dist = player.position.distanceTo(obj.pos);
        if(dist < obj.radius + 15) {
            const push = player.position.clone().sub(obj.pos).normalize().setY(0);
            player.position.copy(obj.pos.clone().add(push.multiplyScalar(obj.radius + 15)));
        }
    });
}

function spawnImpactVFX(pos, color = 0xffffff, isDust = false) {
    const group = new THREE.Group(); 
    const m = new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: isDust ? 0.4 : 1.0});
    for(let i=0; i< (isDust ? 6 : 12); i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), m); p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*8, Math.random()*8, (Math.random()-0.5)*8); group.add(p);
    }
    group.position.copy(pos); scene.add(group);
    let frames = isDust ? 20 : 40;
    const interval = setInterval(() => {
        group.children.forEach(c => { c.position.add(c.userData.velocity); c.userData.velocity.y -= 0.5; c.scale.multiplyScalar(0.9); });
        frames--; if(frames <= 0) { removeAndDispose(group); clearInterval(interval); }
    }, 20);
}

/** ==========================================
 * PS1 ANIMAL AI ENGINE (HERDING)
 * ========================================== */
function updateAnimalAI(anim, dt, time, flockArr, penTarget) {
    const data = anim.userData; const distToPlayer = player.position.distanceTo(anim.position); const distToPen = anim.position.distanceTo(penTarget);
    let isPushed = false; let pushSource = null;
    
    if (distToPlayer < 150) { isPushed = true; pushSource = player.position; }
    else { let nearestHerderDist = 150; npcs.forEach(n => { if(n.userData.task === 'HERD') { let d = n.position.distanceTo(anim.position); if(d < nearestHerderDist) { nearestHerderDist = d; pushSource = n.position; isPushed = true; } } }); }

    if (!data.secured && isPushed) {
        if(data.state === 'GRAZE') { data.state = 'ALERT'; data.fear = 0.5; }
        else if (data.state === 'ALERT' && data.fear <= 0) { data.state = 'FLEE'; data.fear = 4.0; }
        else if (data.state === 'FLEE') { data.fear = 4.0; }
    } else if (data.secured) { data.state = 'SECURED'; } 
    else if (data.fear > 0) { data.fear -= dt; data.state = data.fear <= 0 ? 'GRAZE' : (data.state === 'ALERT' ? 'ALERT' : 'FLEE'); } 
    else { data.state = 'GRAZE'; }

    let desiredVelocity = new THREE.Vector3(); let targetSpeed = 0;

    if (data.state === 'FLEE' && pushSource) {
        targetSpeed = data.maxSpeed;
        if (Math.random() < 0.02 && data.type === 'sheep') sfx.sheep();
        let awayVec = anim.position.clone().sub(pushSource).normalize(); let penVec = penTarget.clone().sub(anim.position).normalize();
        desiredVelocity.copy(awayVec).multiplyScalar(0.4).add(penVec.multiplyScalar(0.6)).normalize();
        if (distToPen < 200) { data.secured = true; logUpdate((data.type === 'sheep' ? "Sheep" : (data.type === 'camel' ? "Camel" : "Oxen")) + " guided to fold."); animateCounter(data.type === 'sheep' ? 'v-s' : 'v-c'); }
    } else if (data.state === 'GRAZE') {
        targetSpeed = data.maxSpeed * 0.2; data.grazeTimer -= dt;
        if (data.grazeTimer <= 0) { data.grazeTimer = 2 + Math.random() * 4; data.targetDir.set((Math.random() - 0.5), 0, (Math.random() - 0.5)).normalize(); if(Math.random() < 0.4) targetSpeed = 0; }
        desiredVelocity.copy(data.targetDir);
    } else if (data.state === 'ALERT') {
        targetSpeed = 0; data.fear -= dt; desiredVelocity.copy(anim.position).sub(pushSource || player.position).normalize();
    } else if (data.state === 'SECURED') {
        targetSpeed = data.maxSpeed * 0.15; data.grazeTimer -= dt;
        if (data.grazeTimer <= 0) { data.grazeTimer = 2 + Math.random() * 3; let toCenter = penTarget.clone().sub(anim.position).normalize(); data.targetDir.set((Math.random() - 0.5) + toCenter.x, 0, (Math.random() - 0.5) + toCenter.z).normalize(); if(Math.random() < 0.5) targetSpeed = 0; }
        desiredVelocity.copy(data.targetDir);
    }

    let sepVec = new THREE.Vector3(); let sepCount = 0;
    flockArr.forEach(other => { if(other !== anim && anim.position.distanceTo(other.position) < 25) { sepVec.add(anim.position.clone().sub(other.position).normalize()); sepCount++; } });
    if(sepCount > 0 && targetSpeed > 0) { sepVec.divideScalar(sepCount).normalize(); desiredVelocity.add(sepVec.multiplyScalar(1.5)).normalize(); }

    data.speed += (targetSpeed - data.speed) * dt * 5;
    data.velocity.copy(desiredVelocity).multiplyScalar(data.speed);
    
    anim.position.x += data.velocity.x * dt; anim.position.z += data.velocity.z * dt;
    if (data.velocity.lengthSq() > 0.1) data.targetYaw = Math.atan2(data.velocity.x, data.velocity.z);
    anim.rotation.y = lerpAngle(anim.rotation.y, data.targetYaw, dt * 8);

    const targetY = getTerrainHeight(anim.position.x, anim.position.z);
    anim.position.y += (targetY - anim.position.y) * dt * 10;

    const fwdX = anim.position.x + Math.sin(anim.rotation.y) * 10; const fwdZ = anim.position.z + Math.cos(anim.rotation.y) * 10;
    const bwdX = anim.position.x - Math.sin(anim.rotation.y) * 10; const bwdZ = anim.position.z - Math.cos(anim.rotation.y) * 10;
    anim.rotation.x += (Math.atan2(getTerrainHeight(bwdX, bwdZ) - getTerrainHeight(fwdX, fwdZ), 20) - anim.rotation.x) * dt * 5;

    const speedRatio = data.speed / data.maxSpeed;
    if(!data.isGLTF) {
        if (speedRatio > 0.1) {
            const animSpeed = time * 15 * (speedRatio > 0.5 ? 1.5 : 1);
            if(data.legs) data.legs.forEach((leg, i) => { leg.rotation.x = Math.sin(animSpeed + (i % 2 === 0 ? 0 : Math.PI)) * 0.6 * speedRatio; });
            if(data.body) data.body.position.y = data.baseY + Math.abs(Math.sin(animSpeed)) * 1.5 * speedRatio;
        } else {
            if(data.legs) data.legs.forEach(leg => leg.rotation.x += (0 - leg.rotation.x) * dt * 5);
            if(data.body) data.body.position.y += (data.baseY + Math.sin(time * 2) * 0.5 - data.body.position.y) * dt * 5;
        }
    }
}

/** ==========================================
 * MAIN UPDATE LOOP
 * ========================================== */
function startLoop() {
    requestAnimationFrame(mainLoop);
}

async function mainLoop() {
    const dt = Math.min(clock.getDelta(), 0.1); 
    const time = Date.now() * 0.005;

    // Update GLTF Animations
    animMixers.forEach(m => m.mixer.update(dt));
    updateInstancedFlock();

    if(window.treeShaders) window.treeShaders.forEach(s => s.uniforms.time.value = time);
    if(waterMat) waterMat.uniforms.time.value += dt;

    if(gameSun) { gameSun.position.x = Math.sin(time * 0.1) * 300; gameSun.position.z = Math.cos(time * 0.1) * 300 - 500; }
    if(dustSystem) dustSystem.rotation.y = time * 0.05;
    
    // Ensure shadows update even if autoUpdate is false (Better performance)
    if(renderer.shadowMap.autoUpdate === false) renderer.shadowMap.needsUpdate = true;

    if(window.activeFires) {
        window.activeFires.forEach(f => {
            f.children.forEach(p => {
                p.position.y += p.userData.speed * dt * 300;
                p.rotation.x += p.userData.speed * dt * 10;
                p.rotation.y += p.userData.speed * dt * 10;
                if(p.position.y > p.userData.yMax) p.position.y = 0;
            });
        });
    }

    if(window.whirlwindGrp) {
        window.whirlwindGrp.children.forEach(p => {
            p.userData.angle += p.userData.speed * dt * 50;
            p.position.x = Math.sin(p.userData.angle) * p.userData.radius;
            p.position.z = Math.cos(p.userData.angle) * p.userData.radius;
            if(p.userData.isDebris) { p.rotation.x += 0.2; p.rotation.z += 0.2; } else { p.rotation.y += 0.1; }
        });
    }

    let targetSky = new THREE.Color(0x87ceeb);
    if (sim.mode === 'WEALTH' && sim.threat > 60) targetSky = new THREE.Color(0xd4af37);
    else if (sim.mode === 'STRUCK' || sim.day === 5) targetSky = new THREE.Color(0x222222);
    if (sim.state === 'WHIRLWIND') targetSky = new THREE.Color(0x1a1a5a);
    scene.fog.color.lerp(targetSky, 0.01);

    const ring = document.getElementById('danger-ring');
    if(sim.al < 30) { ring.style.borderWidth = "40px"; ring.style.borderColor = `rgba(139, 0, 0, ${0.2 + Math.sin(time)*0.2})`; } 
    else { ring.style.borderWidth = "0px"; }

    if (sim.ritual && !isDisasterRunning) {
        sim.nPos += 4.8 * dt * 60;
        if (sim.nPos > 96) sim.nPos = 0;
        const needleEl = document.getElementById('needle');
        needleEl.style.left = sim.nPos + "%";
    }

    if(!isDisasterRunning && sim.mode === 'WEALTH') {
        sim.threat = Math.min(100, sim.threat + (sim.grain * 0.0001));
        if(sim.day > 1 && sim.day < 4) {
            let raiderCount = enemies.filter(e => e.userData.type === 'raider').length;
            if(Math.random() < sim.threat * 0.00005 && raiderCount < 2) { 
                createRaiderMesh(Math.random()*2000, Math.random()*2000); 
                logUpdate("A lone raider scout detected."); sfx.danger(); 
            }
            if(Math.random() < 0.001 && enemies.length < 4) { spawnWolf((Math.random()-0.5)*3000, (Math.random()-0.5)*3000); sfx.wolf(); }
        }
        
        enemies.forEach(r => {
            const data = r.userData; const dist = r.position.distanceTo(player.position);
            if(dist > 2000) return; 
            
            if(data.state === 'PATROL') {
                r.position.x += Math.sin(time + (r.id||1)) * 0.5; r.position.z += Math.cos(time + (r.id||1)) * 0.5;
                if(dist < 400) data.state = 'CHASE';
            } else if(data.state === 'CHASE') {
                const dir = player.position.clone().sub(r.position).normalize();
                r.position.add(dir.multiplyScalar(120 * dt)); r.rotation.y = lerpAngle(r.rotation.y, Math.atan2(dir.x, dir.z), dt * 8);
                if(dist < 60) data.state = 'ATTACK';
            } else if(data.state === 'ATTACK') {
                if(data.cooldown <= 0) { sim.al -= 1; data.cooldown = 1.5; sfx.hit(); flashDanger(); vibrate([50, 50]); }
                data.cooldown -= dt;
                if(dist > 80) data.state = 'CHASE';
            }
            r.position.y += ((getTerrainHeight(r.position.x, r.position.z) + 15) - r.position.y) * dt * 10;
        });
    }

    birds.forEach(b => {
        const d = b.userData; d.angle += d.speed;
        b.position.set(Math.sin(d.angle) * 800, d.height + Math.sin(time) * 10, Math.cos(d.angle) * 800);
        b.lookAt(0, 300, 0); 
        if(!d.isGLTF) { if(d.wingL) d.wingL.rotation.z = Math.sin(time * 8) * 0.4; if(d.wingR) d.wingR.rotation.z = -Math.sin(time * 8) * 0.4; }
    });

    npcs.forEach(npc => {
        if(player.position.distanceTo(npc.position) > 1500) return;
        const dist = player.position.distanceTo(npc.position);
        if(dist < 120 && !npc.userData.prompted) { logUpdate(npc.userData.label + " awaits."); npc.userData.prompted = true; sfx.ui(); }
        if(dist > 150) npc.userData.prompted = false;

        let desiredRot = npc.rotation.y;
        if(npc.userData.task === 'HERD') {
            let targetAnimal = null; let minDist = 9999;
            [...flock, ...camelHerd].forEach(a => {
                if(!a.userData.secured) {
                    let d = npc.position.distanceTo(a.position);
                    if(d < minDist) { minDist = d; targetAnimal = a; }
                }
            });
            if(targetAnimal) {
                let penTgt = targetAnimal.userData.type === 'sheep' ? sheepPenTarget : camelPenTarget;
                let dirFromPen = targetAnimal.position.clone().sub(penTgt).normalize();
                let approachPos = targetAnimal.position.clone().add(dirFromPen.multiplyScalar(80));
                
                const dir = approachPos.sub(npc.position).normalize();
                if(npc.position.distanceTo(approachPos) > 10) {
                    npc.position.add(dir.multiplyScalar(60*dt)); 
                    desiredRot = Math.atan2(dir.x, dir.z);
                }
            } else {
                npc.userData.task = 'IDLE';
                logUpdate(npc.userData.label + " finished herding.");
            }
        } else {
            if(Math.random() < 0.005) npc.userData.target.set(npc.position.x + (Math.random()-0.5)*300, 0, npc.position.z + (Math.random()-0.5)*300);
            const dir = npc.userData.target.clone().sub(npc.position);
            if(dir.length() > 10) { dir.normalize(); npc.position.add(dir.multiplyScalar(20 * dt)); desiredRot = Math.atan2(dir.x, dir.z); }
        }
        npc.rotation.y = lerpAngle(npc.rotation.y, desiredRot, dt * 5);
        npc.position.y += (getTerrainHeight(npc.position.x, npc.position.z) - npc.position.y) * dt * 10;
    });

    if(!sim.ritual && !sim.diag && sim.playerState !== 'LAMENTING') {
        let ix = 0, iz = 0;
        if(keys['w']) iz -= 1; if(keys['s']) iz += 1;
        if(keys['a']) ix -= 1; if(keys['d']) ix += 1;
        if(joystickMove) { ix = moveVec.x; iz = moveVec.z; }

        let inputVec = new THREE.Vector3(ix, 0, iz);
        if(inputVec.lengthSq() > 1) inputVec.normalize();
        inputVec.applyAxisAngle(new THREE.Vector3(0,1,0), camYaw);

        if(inputVec.lengthSq() > 0.01) {
            pVelocity.add(inputVec.multiplyScalar(pAccel * dt));
            const currentMax = pMaxSpeed * (sim.stam < 20 ? 0.5 : 1.0);
            if(pVelocity.length() > currentMax) pVelocity.normalize().multiplyScalar(currentMax);
        }
        pVelocity.lerp(new THREE.Vector3(0,0,0), pFriction * dt);
        pSpeed = pVelocity.length();

        if(pSpeed > 1) {
            player.position.add(pVelocity.clone().multiplyScalar(dt));
            let targetRot = Math.atan2(pVelocity.x, pVelocity.z);
            player.rotation.y = lerpAngle(player.rotation.y, targetRot, dt * 10);
            handleCollisions();
            
            // Dust kick-up when moving fast
            if (pSpeed > 200 && Math.random() < 0.1) {
                spawnImpactVFX(new THREE.Vector3(player.position.x, player.position.y - 10, player.position.z), 0xddaa77, true);
            }
        }

        player.position.y = getTerrainHeight(player.position.x, player.position.z);

        const fwdX = player.position.x + Math.sin(player.rotation.y) * 10; const fwdZ = player.position.z + Math.cos(player.rotation.y) * 10;
        const bwdX = player.position.x - Math.sin(player.rotation.y) * 10; const bwdZ = player.position.z - Math.cos(player.rotation.y) * 10;
        const slopeX = Math.atan2(getTerrainHeight(bwdX, bwdZ) - getTerrainHeight(fwdX, fwdZ), 20);
        donkeyGrp.rotation.x = lerpAngle(donkeyGrp.rotation.x, slopeX, dt * 5);

        if(!donkeyGrp.userData.isGLTF) {
            if(pSpeed > 10) {
                const animSpd = time * 15 * (pSpeed/pMaxSpeed);
                donkeyLegs.forEach((leg, i) => { leg.rotation.x = Math.sin(animSpd + (i%2===0?0:Math.PI)) * 0.8 * (pSpeed/pMaxSpeed); });
                donkeyGrp.position.y = Math.abs(Math.sin(animSpd)) * 3;
                heroGrp.position.y = 55 + Math.abs(Math.sin(animSpd)) * 1.5;
            } else {
                donkeyLegs.forEach(leg => leg.rotation.x += (0 - leg.rotation.x) * dt * 8);
                donkeyGrp.position.y += (0 - donkeyGrp.position.y) * dt * 8;
                heroGrp.position.y += (55 - heroGrp.position.y) * dt * 8;
            }
        }

        let pSheep = 0, pCamel = 0;
        flock.forEach(s => { if(player.position.distanceTo(s.position) < 1500) updateAnimalAI(s, dt, time, flock, sheepPenTarget); if(s.userData.secured) pSheep++; });
        camelHerd.forEach(c => { if(player.position.distanceTo(c.position) < 1500) updateAnimalAI(c, dt, time, camelHerd, camelPenTarget); if(c.userData.secured) pCamel++; });
        
        if (sim.sheep > 0 && pSheep !== parseInt(document.getElementById('v-s').innerText)) animateCounter('v-s');
        if (sim.camels > 0 && pCamel !== parseInt(document.getElementById('v-c').innerText)) animateCounter('v-c');
        
        document.getElementById('v-s').innerText = sim.sheep === 0 ? 0 : sim.sheep - 16 + pSheep;
        document.getElementById('v-c').innerText = sim.camels === 0 ? 0 : sim.camels - 5 + pCamel;
    }

    renderLabels();
    
    const camTargetObj = sim.playerState === 'LAMENTING' ? heroGrp : player;
    const cX = camTargetObj.position.x + Math.sin(camYaw) * 220;
    const cZ = camTargetObj.position.z + Math.cos(camYaw) * 220;
    let cY = camTargetObj.position.y + 150;
    
    if(pSpeed > 15 && sim.playerState !== 'LAMENTING') {
        cY += Math.sin(time * 15) * 4 * (pSpeed/pMaxSpeed);
    }
    
    targetCamPos.set(cX, cY, cZ);
    camera.position.lerp(targetCamPos, dt * 4);
    camera.lookAt(camTargetObj.position.x, camTargetObj.position.y + 50, camTargetObj.position.z);
    
    if(isWebGPU) {
        await renderer.renderAsync(scene, camera);
    } else {
        composer.render();
    }
    
    requestAnimationFrame(mainLoop);
}

/** ==========================================
 * INTERACTIONS & SYSTEMS
 * ========================================== */
function logUpdate(m){ 
    const l = document.getElementById('chronicle'); 
    l.innerHTML = `<div>‚Ä¢ ${m}</div>` + l.innerHTML; 
}

function flashDanger() { 
    const r=document.getElementById('danger-ring'); 
    r.style.background="rgba(139,0,0,0.3)"; 
    setTimeout(()=>r.style.background="transparent",200); 
}

function animateCounter(id) {
    const el = document.getElementById(id);
    el.style.transform = 'scale(1.5) rotate(-5deg)';
    el.style.color = '#ffe55c';
    setTimeout(() => { el.style.transform = 'scale(1) rotate(0deg)'; el.style.color = 'inherit'; }, 200);
}

function updateTheme() {
    const root = document.documentElement;
    if (sim.mode === 'STRUCK') {
        root.style.setProperty('--paper-bg', 'linear-gradient(145deg, rgba(60,50,45,0.95), rgba(30,20,15,0.95))');
        root.style.setProperty('--gold', '#888');
        root.style.setProperty('--gold-dark', '#444');
        if(!isWebGPU && bloomPass) bloomPass.strength = 0.4;
    } else if (sim.state === 'WHIRLWIND') {
        root.style.setProperty('--paper-bg', 'linear-gradient(145deg, rgba(30,10,40,0.95), rgba(10,5,20,0.95))');
        if(!isWebGPU && bloomPass) bloomPass.strength = 0.8;
    } else if (sim.state === 'RESTORED') {
        root.style.setProperty('--paper-bg', 'linear-gradient(145deg, rgba(255,250,230,0.95), rgba(212,175,55,0.95))');
        if(!isWebGPU && bloomPass) bloomPass.strength = 1.8;
    }
}

function act(n,c){ 
    if(sim.day === 5) { logUpdate("In your grief, labor means nothing. (Action blocked)"); sfx.danger(); return; }
    if(sim.ap>=c){ 
        sim.ap-=c; sim.stam-=10; sim.threat+=5; sim.grain+=20; sim.wood+=15; 
        logUpdate(n+" work finished."); sfx.harvest(); animateCounter('v-g'); animateCounter('v-w'); updateHUD(); 
    }
}

function startOffering(){ if(sim.ap < 10) return; sim.ritual=true; document.getElementById('ritual-ui').style.display='block'; sim.strikes=0; document.getElementById('r-status').innerText="STRIKES: 0/5 (Tap/Space)"; sfx.ui(); }

function attemptRitualStrike() {
    if (!sim.ritual || isDisasterRunning) return;
    const needle = document.getElementById('needle');
    const perfect = sim.nPos > 39 && sim.nPos < 61;
    
    if (perfect) {
        sim.strikes++;
        document.getElementById('r-status').innerText = `STRIKES: ${sim.strikes}/5 (PERFECT!)`;
        needle.style.boxShadow = '0 0 30px #ff0';
        sfx.ritualSuccess();
        setTimeout(() => needle.style.boxShadow = '0 0 10px #fff', 200);
        
        const f = document.getElementById('fader');
        f.style.transition = 'none'; f.style.background = '#ffe55c'; f.style.opacity = 0.5;
        setTimeout(() => { f.style.transition = 'opacity 0.4s'; f.style.opacity = 0; setTimeout(()=>f.style.background='black',400); }, 50);

    } else {
        sfx.ritualMiss();
        needle.style.boxShadow = '0 0 20px #f00';
        setTimeout(() => needle.style.boxShadow = '0 0 10px #fff', 150);
    }
    
    if (sim.strikes >= 5) {
        sim.ritual = false;
        document.getElementById('ritual-ui').style.display = 'none';
        sim.ap -= 10;
        sim.al += 15;
        updateHUD();
        if (sim.day === 5) triggerWife();
        logUpdate("Burnt offering accepted by YHWH.");
    }
}

function buildAltar() {
    if(sim.wood >= 20 && sim.ap >= 10) {
        sim.wood -= 20; sim.ap -= 10; sim.hasAltar = true;
        logUpdate("Sacred Altar built.");
        
        const altarGrp = new THREE.Group();
        if (modelCache.temple) {
            const m = SkeletonUtils.clone(modelCache.temple.scene);
            m.scale.set(5, 5, 5); 
            altarGrp.add(m);
        } else {
            const base = new THREE.Mesh(new THREE.BoxGeometry(40, 20, 40), pbrMat('#aaaaaa', 0.9)); base.position.y = 10;
            const top = new THREE.Mesh(new THREE.BoxGeometry(30, 10, 30), pbrMat('#888888', 0.9)); top.position.y = 25;
            altarGrp.add(base, top);
        }
        
        const spawnPos = player.position.clone().add(new THREE.Vector3(Math.sin(player.rotation.y)*80, 0, Math.cos(player.rotation.y)*80));
        spawnPos.y = getTerrainHeight(spawnPos.x, spawnPos.z);
        altarGrp.position.copy(spawnPos);
        altarGrp.userData = { label: "Sacred Altar" };
        scene.add(altarGrp); tags.push(altarGrp); colliders.push({pos: spawnPos, radius: 25});
        
        updateHUD(); sfx.wood();
    } else { logUpdate("Not enough Wood (20) or AP (10) for Altar."); sfx.danger(); }
}

function expandFold() {
    if(sim.wood >= 30 && sim.ap >= 10) {
        sim.wood -= 30; sim.ap -= 10;
        logUpdate("Herds expanded. Estate grows.");
        for(let i=0; i<3; i++) spawnSheep();
        for(let i=0; i<1; i++) spawnCamel();
        sim.sheep += 300; sim.camels += 100;
        sfx.wood(); updateHUD(); animateCounter('v-s'); animateCounter('v-c');
    } else { logUpdate("Need 30 Wood and 10 AP to expand fold."); sfx.danger(); }
}

function pray() {
    if(sim.ap >= 5) {
        sim.ap -= 5;
        let alGain = sim.hasAltar ? 10 : 5;
        sim.al = Math.min(100, sim.al + alGain);
        logUpdate(sim.hasAltar ? "You prayed at the altar. Spirit lifted." : "You prayed in the wilderness.");
        sfx.ui(); updateHUD();
    } else { logUpdate("Not enough AP to pray."); sfx.danger(); }
}

function executeStaffStrike() {
    const now = Date.now();
    if(now - lastStaffStrike < 400 || sim.ritual || sim.playerState === 'LAMENTING') return;
    lastStaffStrike = now; sfx.harvest(); vibrate(50);
    
    if(window.staffMesh) {
        window.staffMesh.rotation.x -= 1.2; setTimeout(() => { window.staffMesh.rotation.x += 1.2; }, 150);
    }

    let hit = false;
    enemies.forEach((enemy, idx) => {
        if(player.position.distanceTo(enemy.position) < 110) {
            enemy.userData.hp -= 45; spawnImpactVFX(enemy.position, 0xff0000); sfx.hit();
            logUpdate("You struck at the threat!"); hit = true;
            if(enemy.userData.hp <= 0) { removeAndDispose(enemy); enemies.splice(idx, 1); tags.splice(tags.indexOf(enemy), 1); }
        }
    });

    if(!hit && harvestNodes && sim.day !== 5) {
        harvestNodes.forEach((node, idx) => {
            if(player.position.distanceTo(node.position) < 130) {
                node.userData.hp--; spawnImpactVFX(node.position, 0xaaaaaa); sfx.wood();
                if(node.userData.hp <= 0) {
                    if(node.userData.type === 'grain') { sim.grain += 10; logUpdate("Harvested Field."); animateCounter('v-g'); } 
                    else if(node.userData.type === 'wood') { sim.wood += 5; logUpdate("Timber Felled."); animateCounter('v-w'); }
                    removeAndDispose(node); harvestNodes.splice(idx, 1); tags.splice(tags.indexOf(node), 1);
                }
            }
        });
    }
}

function npcInteraction() {
    sfx.ui(); vibrate(20);
    if(sim.mode === 'WEALTH') {
        const nearNpc = npcs.find(n => player.position.distanceTo(n.position) < 150);
        if(nearNpc) {
            openDialogue(nearNpc.userData.label, "Yes, my lord Job?", [
                {t: "Command: Herd the animals.", f: () => { nearNpc.userData.task = 'HERD'; logUpdate(nearNpc.userData.label + " is securing the herds."); }},
                {t: "Nevermind.", f: () => {}}
            ]);
        } else logUpdate("No one is nearby to hear you.");
    }
    else if (sim.mode === 'STRUCK') {
        sim.round++;
        if(sim.round === 1) { 
            openDialogue("Eliphaz the Temanite", "Those who plow iniquity reap the same. The innocent do not perish. Call upon YHWH.", [
                {t: "I will hold fast my integrity until death!", f: ()=>{sim.al+=20;}},
                {t: "My days are swifter than a weaver‚Äôs shuttle...", f: ()=>{sim.al-=10;}}
            ]);
        } else if(sim.round === 2) { 
            openDialogue("Bildad the Shuhite", "Does YHWH pervert justice? Seek Him diligently and He will restore you.", [
                {t: "How can a man be righteous before YHWH?", f: ()=>{sim.al+=15;}},
                {t: "He destroys both the blameless and the wicked.", f: ()=>{sim.al-=25;}}
            ]);
        } else { 
            openDialogue("Zophar the Naamathite", "Should a man full of talk be justified? YHWH knows the empty words of man. Repent!", [
                {t: "Oh that YHWH would answer me!", f: ()=>{sim.al+=10; whirlwindTrigger();}},
                {t: "I am weary of this.", f: ()=>{sim.al-=5;}}
            ]);
        }
    }
}

function updateHUD(){
    document.getElementById('ap-fill').style.width = (sim.ap/30*100) + "%";
    document.getElementById('al-fill').style.width = sim.al + "%";
    document.getElementById('th-fill').style.width = sim.threat + "%";
    document.getElementById('stam-fill').style.width = sim.stam + "%";
    document.getElementById('v-g').innerText = sim.grain;
    document.getElementById('v-w').innerText = sim.wood;
    
    document.getElementById('end-day-btn').style.display = (sim.ap < 3 || sim.day === 5) ? 'block' : 'none';
}

function renderLabels(){
    const lHost = document.getElementById('labels-hud'); lHost.innerHTML = "";
    tags.forEach(t => {
        const dist = camera.position.distanceTo(t.position);
        if(dist > 1200) return; 
        
        const v = t.position.clone().add(new THREE.Vector3(0,100,0)).project(camera);
        if(v.z < 1) { 
            const x = (v.x*0.5+0.5) * window.innerWidth; 
            const y = (v.y*-0.5+0.5) * window.innerHeight; 
            const scale = Math.max(0.4, 1 - (dist/1200));
            const opacity = Math.max(0.1, 1 - (dist/900));
            lHost.innerHTML += `<div class="world-label" style="left:${x}px; top:${y}px; transform:translate(-50%,-130%) scale(${scale}); opacity:${opacity};">${t.userData.label}</div>`; 
        }
    });
}

function openDialogue(n,m,opts){
    sim.diag = true; sfx.ui(); const box=document.getElementById('script-overlay'); 
    document.getElementById('d-name').innerText=n; 
    
    const dText = document.getElementById('d-text');
    dText.innerText = "";
    clearInterval(window.typewriterInt);
    let charIdx = 0;
    window.typewriterInt = setInterval(() => {
        dText.innerText += m.charAt(charIdx); charIdx++;
        if (charIdx >= m.length) clearInterval(window.typewriterInt);
    }, 25);

    const choiceBox=document.getElementById('d-choices'); choiceBox.innerHTML="";
    opts.forEach(o => {
        const btn=document.createElement('button'); btn.className="choice-btn"; btn.innerText=o.t; 
        btn.onclick=() => { 
            clearInterval(window.typewriterInt); o.f(); sfx.ui(); vibrate(15); 
            box.style.display='none'; sim.diag=false; updateHUD(); 
        }; 
        choiceBox.appendChild(btn);
    }); 
    box.style.display='block';
}

/** ==========================================
 * STORY EVENTS & CALAMITIES
 * ========================================== */
function nightTransition() {
    document.getElementById('fader').style.opacity = 1;
    setTimeout(() => {
        if(sim.day === 3) { triggerCalamityWaves(); document.getElementById('fader').style.opacity = 0; } 
        else if(sim.day === 4) { setupDay5(); document.getElementById('fader').style.opacity = 0; }
        else if(sim.day === 5) { postCalamitySetup(); }
        else {
            sim.day++; sim.ap = 30; sim.stam = 100; document.getElementById('fader').style.opacity = 0;
            document.getElementById('v-day').innerText = sim.day; logUpdate("Sun rises. Tend the stewardship of Uz.");
        }
        updateHUD();
    }, 1500);
}

function triggerCalamityWaves() {
    isDisasterRunning = true; sim.ritual = true; sfx.danger();
    document.getElementById('fader').style.opacity = "0.6"; document.getElementById('fader').style.background = "radial-gradient(circle, transparent 20%, #4a1e1e 100%)";
    
    const w4 = () => { 
        openDialogue("Messenger 4", "A great wind struck the house‚Äîyour children are gone, Job.", [ 
            {
                t: "Blessed be the Name of YHWH.", 
                f: () => {
                    sim.al += 50;
                    sim.day = 4;
                    isDisasterRunning = false;
                    sim.ritual = false;
                    nightTransition();
                }
            }, 
            {
                t: "Why has this happened!?", 
                f: () => {
                    sim.al -= 20;
                    sim.day = 4;
                    isDisasterRunning = false;
                    sim.ritual = false;
                    nightTransition();
                }
            } 
        ]); 
    };
    
    const w3 = () => { for(let i=0; i<3; i++) createRaiderMesh(player.position.x+300, player.position.z+300); openDialogue("Messenger 3", "Chaldeans swept down! Your children...", [ {t: "Continue in Silence...", f: w4} ]); };
    const w2 = () => { 
        sim.sheep=0; flock.forEach(s=>{
            if (s.userData.instanceIndex >= 0 && sheepInstances) {
                sheepInstances.setMatrixAt(s.userData.instanceIndex, new THREE.Matrix4().scale(new THREE.Vector3(0,0,0)));
                sheepInstances.instanceMatrix.needsUpdate = true;
            }
            removeAndDispose(s);
        }); 
        spawnFire(-450, -600); spawnFire(600, -850); spawnFire(player.position.x+100, player.position.z-100);
        openDialogue("Messenger 2", "The fire of YHWH fell and burned up the sheep!", [ {t: "Prepare for Wave 3", f: w3} ]); 
    };
    openDialogue("Messenger 1", "Master! The Sabeans took the oxen and camels!", [ {t: "Endure Wave 1", f: w2} ]);
    sim.camels = 0; camelHerd.forEach(c=>removeAndDispose(c));
}

function setupDay5() {
    isDisasterRunning = false; sim.ritual = false; sim.day = 5; sim.ap = 30;
    document.getElementById('fader').style.opacity = "0"; document.getElementById('fader').style.background = "black";
    document.getElementById('job-title').innerText = "Day of Mourning"; document.getElementById('env-mode').innerText = "The Silence of Uz";
    document.getElementById('btn-lament').style.display = 'block';
    logUpdate("Your wealth is gone. You cannot harvest or labor. Pray, Sacrifice, or Lament.");
}

function lamentOption() {
    sfx.ui(); openDialogue("The Darkness", "Despair overwhelms you.", [
        {t: "Curse the day I was born.", f: gameOver },
        {t: "Turn to Prayer instead.", f: () => { document.getElementById('btn-lament').style.display = 'none'; triggerWife(); }}
    ]);
}

function triggerWife() {
    openDialogue("Job's Wife", "Do you still hold fast your integrity? Curse YHWH and die!", [
        {t: "You speak as a foolish woman. Shall we receive good from YHWH, and not evil?", f: () => { sim.al+=20; document.getElementById('btn-lament').style.display='none'; logUpdate("You maintained integrity. Proceed to Conclude Day."); }},
        {t: "Perhaps you are right... (Curse YHWH)", f: gameOver }
    ]);
}

function gameOver() {
    document.getElementById('fader').style.opacity = 1;
    setTimeout(() => { document.body.innerHTML += `<div style="position:fixed;inset:0;background:black;color:white;z-index:99999;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;"><h1 style="color:var(--danger);font-family:'Cinzel';font-size:4rem;">SPIRIT BROKEN</h1><p>You have fallen to the adversary's temptation.</p><button onclick="location.reload()" style="margin-top:20px;padding:15px;background:var(--danger);color:white;font-family:'Cinzel';cursor:pointer;border:none;">TRY AGAIN</button></div>`; }, 1500);
}

function postCalamitySetup() {
    document.getElementById('btn-lament').style.display = 'none';
    document.getElementById('fader').style.opacity = "0"; 
    
    if(window.activeFires) { window.activeFires.forEach(f => removeAndDispose(f)); window.activeFires = []; }
    
    sim.day = 6; sim.ap = 0;
    document.getElementById('job-title').innerText = "Job: Afflicted in the Ashes"; document.getElementById('env-mode').innerText = "Outside the Walls of Uz";
    sim.mode = 'STRUCK'; 
    sim.playerState = 'LAMENTING';
    updateTheme();

    scene.add(heroGrp);
    heroGrp.position.copy(player.position);
    heroGrp.position.y = getTerrainHeight(heroGrp.position.x, heroGrp.position.z);
    heroGrp.rotation.set(0.5, player.rotation.y, 0);

    scene.add(donkeyGrp);
    donkeyGrp.position.copy(player.position);
    donkeyGrp.position.x += 40;
    donkeyGrp.position.y = getTerrainHeight(donkeyGrp.position.x, donkeyGrp.position.z);
    donkeyGrp.rotation.set(0, player.rotation.y + 1, 0);

    const boilMat = new THREE.MeshBasicMaterial({color: 0x8b0000});
    for(let i=0; i<20; i++) { const boil = new THREE.Mesh(new THREE.SphereGeometry(1.5, 4, 4), boilMat); boil.position.set((Math.random()-0.5)*15, Math.random()*25, (Math.random()-0.5)*15); heroGrp.add(boil); }
    logUpdate("Satan struck Job with boils. He sat in the ashes."); sfx.danger();

    const friends = [
        {n:"Eliphaz", m:"eliphaz", c:'#2d4a69', x:50, z:50}, 
        {n:"Bildad", m:"bildad", c:'#2d694a', x:-50, z:50}, 
        {n:"Zophar", m:"zophar", c:'#693a2d', x:0, z:-70}
    ];

    friends.forEach(f => {
        const g = new THREE.Group(); 
        if(modelCache[f.m]) {
            const mod = SkeletonUtils.clone(modelCache[f.m].scene);
            mod.scale.set(10,10,10);
            g.add(mod);
        } else {
            const b = new THREE.Mesh(new THREE.BoxGeometry(18, 50, 18), pbrMat(f.c)); b.position.y=25; 
            const beard = new THREE.Mesh(new THREE.BoxGeometry(10, 15, 4), pbrMat('#aaaaaa')); beard.position.set(0, 40, 9);
            g.add(b, beard);
        }
        g.position.set(f.x, 0, f.z); g.userData={label:f.n+" the Temanite"}; scene.add(g); tags.push(g); npcs.push(g);
    });
    updateHUD();
}

function whirlwindTrigger() {
    sim.state = 'WHIRLWIND'; updateTheme();
    document.getElementById('env-mode').innerText = "THE WHIRLWIND OF YHWH"; logUpdate("YHWH ANSWERED JOB OUT OF THE WHIRLWIND...");
    sfx.play(40, 'square', 4, 0.6); 
    spawnWhirlwind(); 
    
    let shakeT = 0;
    const sInt = setInterval(() => { 
        camera.position.x+=(Math.random()-0.5)*5; camera.position.y+=(Math.random()-0.5)*5; shakeT++; 
        if(shakeT>60){
            clearInterval(sInt); 
            openDialogue("YHWH out of the Whirlwind", "Where were you when I laid the foundations of the earth? Have you commanded the morning? Declare if you have understanding!", [ 
                {t: "Behold, I am of small account. I lay my hand over my mouth.", f: finaleRestoration}, 
                {t: "I repent in dust and ashes before YHWH.", f: finaleRestoration} 
            ]);
        } 
    }, 50);
}

function finaleRestoration() {
    document.getElementById('fader').style.opacity = 1;
    setTimeout(() => {
        document.getElementById('fader').style.opacity = 0; sim.mode = 'WEALTH'; sim.state = 'RESTORED'; updateTheme();
        
        if(window.whirlwindGrp) { removeAndDispose(window.whirlwindGrp); window.whirlwindGrp = null; }

        sim.playerState = 'MOUNTED';
        player.add(donkeyGrp);
        player.add(heroGrp);
        donkeyGrp.position.set(0,0,0); donkeyGrp.rotation.set(0,0,0);
        heroGrp.position.set(0,55,0); heroGrp.rotation.set(0,0,0);
        
        heroGrp.children.forEach(c => { if(c.geometry.type === 'SphereGeometry' && c.scale.x < 1) removeAndDispose(c); });
        
        sim.sheep=14000; sim.camels=6000; sim.grain=400; sim.al=100; 
        sfx.play(400, 'sine', 0.5); setTimeout(()=>sfx.play(600,'sine',1), 500);
        document.getElementById('v-day').innerText = "RESTORED"; document.getElementById('job-title').innerText = "Ancient Patriarch";
        logUpdate("YHWH BLESSED JOB MORE THAN HIS BEGINNING."); updateHUD();

        for(let i=0; i<5; i++) setTimeout(()=>spawnImpactVFX(player.position, 0xffd700), i*200);
        
        let r = "PATIENT SERVANT"; if(sim.al>80) r="GLORIFIED GUARDIAN"; else if(sim.al<40) r="OUTCAST SEEKER";
        document.body.innerHTML += `<div style="position:fixed; inset:0; background:black; color:white; z-index:99999; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding: 40px; font-family:'Cinzel';"> <h1 style="color:var(--gold); font-size:4rem; text-shadow: 0 0 20px var(--gold);">MISSION COMPLETE</h1> <p style="font-size:2rem; border:2px solid var(--gold); padding:20px; box-shadow: inset 0 0 20px rgba(212,175,55,0.2);">RANK ATTAINED: ${r}</p> <p style="max-width:700px; font-size:1.4rem; color:#aaa; font-family:'VT323';">Your Spirit Alignment of ${sim.al}% has been uploaded to the APEX Network.</p> <button onclick="location.reload()" style="margin-top:40px; padding:20px 40px; background:linear-gradient(180deg, var(--gold), var(--gold-dark)); color:black; font-family:'Cinzel'; font-weight:bold; border:none; border-radius:4px; cursor:pointer; box-shadow: 0 4px 15px rgba(212,175,55,0.4);">Enter the Kingdom</button> </div>`;
    }, 2000);
}

window.toggleMenu = toggleMenu;
window.act = act;
window.startOffering = startOffering;
window.buildAltar = buildAltar;
window.expandFold = expandFold;
window.pray = pray;
window.npcInteraction = npcInteraction;
window.lamentOption = lamentOption;
window.nightTransition = nightTransition;
window.executeStaffStrike = executeStaffStrike;
window.attemptRitualStrike = attemptRitualStrike;

// TRIGGER PRELOADER ON LOAD
preloadAndInit();
</script>
</body>
</html>
